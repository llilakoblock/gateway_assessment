## Тестовая среда

Тестировал на стабилизированной системе, домашний сервер на Xeon 2699v3:
- Отключены C-States процессора для минимизации задержек
- Transparent Huge Pages и ASLR отключены
- Swappiness установлен в 1
- IRQ направлены на CPU 0-1
- Бенчмарки запускались на изолированных CPU 2-3

## Процесс оптимизации

Исходная HFT версия использовала фиксированный массив на 256 уровней вместо динамического Vec. Первые замеры показали преимущество в 40% над Basic версией на больших данных, но отставание на single operations.

### Итерация 1: Оптимизация find_position
Заменил generic `binary_search_by` с замыканием на ручной binary search. Результаты:
- **small**: 160µs → 130µs (-18.6%)
- **medium**: 1.08ms → 797µs (-26.2%)
- **large**: 11.77ms → 8.96ms (-23.6%)
- **single_ops**: 6.33µs → 3.12µs (-50.5%)

Прямые сравнения работают эффективнее `partial_cmp`.

### Итерация 2: Попытка оптимизации указателей
Замена `get_unchecked_mut` на прямую арифметику указателей дала регрессию 31%. Компилятор оптимизирует стандартные методы лучше. Откатились к предыдущей версии.

### Итерация 3-4: Оптимизация размера структур
- Loop unrolling в обработке updates не дал эффекта
- Уменьшение `MAX_LEVELS` с 256 до 64 дало **+20% на large датасете** - меньше памяти больше кэша
- Попытка использовать `u8` для count дала небольшую регрессию, оставил `usize`

### Итерация 5-6: Специализированные оптимизации
- Fast path для top of book не показал улучшений на рандомных тестовых данных, но оставил для реальных сценариев
- Batch insert для снапшотов дал регрессию 4-10% из-за лишнего копирования

### Итерация 7-9: Простые но эффективные улучшения
- **FnvHashMap** вместо HashMap: 1-6% улучшения за счет быстрого хэша
- Удаление проверки `bail!` из горячего цикла: 3-6% улучшения
- Замена `match` на `if` не дала изменений

### Итерация 10-11: SIMD оптимизация
Первая попытка SIMD на структуре `Level {price, quantity}` дала регрессию 50% - данные не были правильно организованы для векторов.

После реорганизации структуры на отдельные массивы `prices[]` и `quantities[]`:
```rust
pub struct ImprovedSide {
    prices: [f64; MAX_LEVELS],
    quantities: [Qty; MAX_LEVELS],
    count: usize,
    is_bid: bool,
}
```

SIMD начал работать, на large датасете получил улучшение почти на миллисекунду.

Можно было еще добавить jemallocator, попробовать целочисленную арифметику + avx2 (_mm256_set_epi64x), паддинг для стороны ордер бука, преалоциррованный мемпул, етц.

Стриминг версия - для воображаемого протокола, udp сервер, при подключении клиента - отправляет актуальный снепшот, после него начинает сразу отправлять инкременталы для инструментов.

Сервер не включал в проект, сама идея - кроссбим для неблокирующих каналов, тред слушающий сокет в busy poll запиненый на CPUn пушит в канал, тред запиненный на CPUn+1 busy pollит приемник канала и парсит месседжи. 
